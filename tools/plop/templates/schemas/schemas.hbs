import { pick } from "rambda";

import { SWAGGER_TAGS } from "#libs/constants/swagger-tags.constants.ts";
import { COMMON_CONTRACTS_V1 } from "#libs/contracts/v1/index.ts";
import { defaultHttpErrorCollection } from "#libs/errors/default-http-error-collection.ts";
import { BadRequestException, ConflictException, ResourceNotFoundException } from "#libs/errors/domain.errors.ts";
{{#if withPagination}}
import { generatePaginatedRouteSchema } from "#libs/pagination/index.ts";
{{/if}}
import { mapHttpErrorsToSchemaErrorCollection } from "#libs/utils/schemas.ts";

import {
  {{upperSnakeCase (singular name)}}_CREATE_INPUT_CONTRACT,
  {{upperSnakeCase (singular name)}}_OUTPUT_CONTRACT,
  {{upperSnakeCase (singular name)}}_UPDATE_INPUT_CONTRACT,
} from "./{{camelCase name}}.contracts.ts";
{{#if withPagination}}
import { {{upperSnakeCase name}}_PAGINATION_CONFIG } from "./{{camelCase name}}.pagination-config.ts";
{{/if}}

const {{camelCase name}}Schemas = {
  {{#if withPagination}}
  getList: generatePaginatedRouteSchema({
    config: {{upperSnakeCase name}}_PAGINATION_CONFIG,
    description: "Get paginated list of {{name}} with filtering, sorting, and search",
    errorSchemas: mapHttpErrorsToSchemaErrorCollection(pick([BadRequestException.name], defaultHttpErrorCollection)),
    summary: "Get {{name}} list",
    tags: SWAGGER_TAGS.{{upperSnakeCase name}},
  }),
  {{/if}}

  getById: {
    tags: SWAGGER_TAGS.{{upperSnakeCase name}},
    description: "Get {{singular name}} by ID",
    params: COMMON_CONTRACTS_V1.id,
    response: {
      200: {{upperSnakeCase (singular name)}}_OUTPUT_CONTRACT,
      ...mapHttpErrorsToSchemaErrorCollection(
        pick([BadRequestException.name, ResourceNotFoundException.name], defaultHttpErrorCollection),
      ),
    },
    summary: "Get {{singular name}} by ID",
  },

  create: {
    tags: SWAGGER_TAGS.{{upperSnakeCase name}},
    body: {{upperSnakeCase (singular name)}}_CREATE_INPUT_CONTRACT,
    description: "Create a new {{singular name}}",
    response: {
      201: {{upperSnakeCase (singular name)}}_OUTPUT_CONTRACT,
      ...mapHttpErrorsToSchemaErrorCollection(
        pick([BadRequestException.name, ConflictException.name], defaultHttpErrorCollection),
      ),
    },
    summary: "Create {{singular name}}",
  },

  update: {
    tags: SWAGGER_TAGS.{{upperSnakeCase name}},
    body: {{upperSnakeCase (singular name)}}_UPDATE_INPUT_CONTRACT,
    description: "Update {{singular name}} by ID",
    params: COMMON_CONTRACTS_V1.id,
    response: {
      200: {{upperSnakeCase (singular name)}}_OUTPUT_CONTRACT,
      ...mapHttpErrorsToSchemaErrorCollection(
        pick([BadRequestException.name, ConflictException.name, ResourceNotFoundException.name], defaultHttpErrorCollection),
      ),
    },
    summary: "Update {{singular name}}",
  },

  delete: {
    tags: SWAGGER_TAGS.{{upperSnakeCase name}},
    description: "Delete {{singular name}} by ID{{#if softDelete}} (soft delete){{/if}}",
    params: COMMON_CONTRACTS_V1.id,
    response: {
      200: {{upperSnakeCase (singular name)}}_OUTPUT_CONTRACT,
      ...mapHttpErrorsToSchemaErrorCollection(
        pick([BadRequestException.name, ResourceNotFoundException.name], defaultHttpErrorCollection),
      ),
    },
    summary: "Delete {{singular name}}",
  },
};

export default {{camelCase name}}Schemas;
